// Display inline code in a small box that retains the correct baseline.
#show raw.where(block: false): box.with(
    fill: luma(240),
    inset: (x: 3pt, y: 0pt),
    outset: (y: 3pt),
    radius: 2pt,
)

  // Display block code in a larger block with more padding.
#show raw.where(block: true): block.with(
    // fill: rgb(249, 251, 254),
    inset: 10pt,
    radius: 2pt,
    stroke: 1pt + luma(200)
)

#set text(font: "Cantarell")
#show link: underline
#let figure = figure.with(
  kind: "image",
  supplement: none,
) // disable prefix in captions

#set page(
  margin: 30pt,
  numbering: "1",
  footer: align(
    center, 
    context(counter(page).display())
  )
)


#align(center)[
#text(size: 20pt)[= Ownership and lifetimes]
How Rust's unique features will help us develop a stable, fast and multi-threaded desktop app
#image("logo/logo.svg", height: 4em)
PLM - Paradigm analysis report 
]

#outline(
 title: "Table of Contents",
)
#pagebreak()

== The problem with Markdown
Markdown has the double advantage to be an easy and useful syntax to learn, and have a large support in numerous chat systems and collaboration tools. Redacting Markdown in VSCode or in a web editor is working fine. GitHub and Gitlab show it natively, the editing experience is good, the problems are elsewhere...

=== Export
First, how do you export your document as PDF if you want to send to someone that needs this format ?
+ You may use `pandoc` that convert it into Latex and then generate a PDF, but the default style is really not the same as the preview visible in VSCode. In addition, changing the style requires some Latex knowledge. This would imply a lot more learning and setup to change a few visual settings.
+ You could use an easier solution, the `Markdown PDF` extension in VSCode. It provides a simple `Export to PDF` action the command palette. But what happens if you don't like the default theme ? You have to write pure CSS to change the style of headings, tables, line height, to remove this strange yellow, etc.
#figure(
  block(stroke: 1pt + black)[
    #image("imgs/markdown-pdf-preview.png", width: 60%),
  ],
  caption: [An example of the default style of PDF documents generated by `Markdown PDF`],
) <fig-markdown-pdf-preview>


=== Syntax highlighting
What about syntax highlighting ? When you integrate code snippets in your reports, you want them to look good or at least like in your IDE. In VSCode, here is how would look the editor at left and the native preview at right. As the `@apply` from TailwindCSS is not integrated in the regex system of `highlight.js`, it breaks the style of other parts (see the last block). In the second block the `ul` and `has` are different types and should not be colored in the same way.
#figure(
  image("imgs/code-preview-vscode.png", width: 80%),
  caption: [The code preview in VSCode using the library `highlight.js`],
) <fig-code-preview-vscode>


#figure(
  image("imgs/java-preview-vscode.png", width: 60%),
  caption: [Another preview of Java code in VSCode. Lots of parts in white are not colorised.],
) <fig-java-preview-vscode>

Now let's say, you don't really remember where you put a very specific note on your disk about some "keyboard shortcuts for my terminal". You have hundreds of notes everywhere for numerous projects. You try to run `grep -r` to find all possible match on all files on your disk. The problem with this approach is that no exact match will be found, because `grep` only find exact match. We would prefer to have approximative matching. You could search by file path with the `find` command on all your disk and filter by a single keyword. You'll probably get hundreds of unrelated results or just no result because the filename is too different.

== Why DME is the solution ?

DME is trying to fix these issues around the PDF export, search and syntax highlighting experience. We didn't have time to tackle PDF export in this semester but we successfully improved the situation on search and code preview.

When you open DME, either with the `dme` command or via the start menu, you can see the home view.

TODO home view screenshot

If you opened with a file as first argument `dme document.md` it would open it and show the preview.

#figure(
  image("imgs/preview-readme.png", width: 60%),
  caption: [Preview of DME's README with DME itself],
) <fig-preview-readme>

The preview doesn't refresh by itself for now, but if the underlying file changed, you can press `r` to reload the preview manually.

The code is now better highlighted, because we used a more advanced highlighting system called Tree-Sitter.

#figure(
  image("imgs/java-preview-demo.png", width: 60%),
  caption: [Here is the same snippet of Java highlighted in DME],
) <fig-java-preview-demo>

DME is also providing a simple but working search system. By pressing `p`, you can access a search dialog that will match fuzzily. It means that you can do typos 

#figure(
  image("imgs/search-demo.png", width: 80%),
  caption: [Searching for some keywords in incorrect order do matches the expected headings],
) <fig-search-demo>

To avoid very low quality match, it removes the low score matches, so you have to type around 2 words to see the first results. The results are streamed, you will see the first one quickly, wait a bit and other might come after that.

#pagebreak()

== Architecture

#figure(
  image("schemas/architecture.png", width: 80%),
  caption: [High level overview of the architecture],
) <fig-search-demo>

We have `dme-core` crate (under `app/core`) as the library where most of the logic is implemented. It contain several modules.

- `preview` responsible for rendering HTML for a given Markdown file, including syntax highlighting of code snippets
- `theming` responsible to generate CSS based on a given theme
- `search` responsible for Markdown indexing and search
- `export` responsible for PDF export (not implemented)

Then we use this library in the desktop app which is separated in 2 main parts
1. The frontend (`app/src`), is the VueJS application written in TypeScript
1. The backend (`app/src-tauri`) in Rust using Tauri. It defines some commands (some functions accessible by the frontend code) using the core library.

== Implementation

The search crate contains two core functionallity:
- The indexation of markdown title on disk
- The search inside the built

An important point is that the indexing process is asynchronous, running in separated threads. The reasons for this is
avoid blocking UI / caller on a start call. Instead, the DiskResearcher make available a Progress struc to know how
much of the markdowns are treated.
=== Indexing the disk

This is the base algorithm of the indexation of markdown title on disk
```
chunks = split the markdown found on disk
for each chunks
    start a thread
        get makrdown content
        extract title base on content
        lock
        write data to shared map of title
        unlock
    end thread
end for
```
=== Searching with the index

This is the base algorithm of the search inside the title map build by the indexing process
```
chunks = split the title map
for each chunks
    start a thread
        evaluate how close the title is to the query
        lock
        write proximity to shared map of results
        unlock
    end thread
end for

search for markdown path matching the query
join and sort results
```

The process of evaluating the proximity of the titles/path and the query use an external crate: nucleo_matcher.
Each results is attributed a score, with the path receiving a 1.3 multiplicatore compared to title to prioritize them.
Those results are then sorted, and a subset is returned.

To ensure the relevency of the resulsts, the sub is calculated as followed:

```
get the highest match proximity-wise
define the lowerbound of accepted matches:
   tale 3/4 of the maximum

filter all matches to keep the one above lowerbound
return the results
```

An important note is that even if we limit the results to let's say 10, we might still get fewer results, if the were deemed
not relevant enough.

== Syntax highlighting

- Tree-Sitter vite fait
- Grammars installation
- Highlighting process
- Exemple paradigme application



```rust
let only_latest_commits: Option<u32> = Some(1);
let mut args = vec!["clone", git_clone_url];
if let Some(count) = only_latest_commits {
    args.push("--depth");
    args.push(&count.to_string());
}
if single_branch {
    args.push("--single-branch");
}
let output = Self::run_git_cmd(&args, base_directory)?;
```

```sh
   Compiling dme-core v0.1.0
error[E0716]: temporary value dropped while borrowed
  --> src/util/git.rs:66:24
   |
66 |             args.push(&count.to_string());
   |                        ^^^^^^^^^^^^^^^^^ - temporary value is freed at the end of this statement
   |                        |
   |                        creates a temporary value which is freed while still in use
...
69 |             args.push("--single-branch");
   |             ---- borrow later used here
   |
   = note: consider using a `let` binding to create a longer lived value
```



== Our experience
=== Our experience with the paradigm
- *Avoided thousands of possible errors* #linebreak()
  We encountered compile errors related to memory safety, which would have probably been missed in a C codebase.
- *Hard to think about advanced memory references* #linebreak()
  Sometimes, with some of the Tree-Sitter types and mutables references required, it was hard to manage some references where referenced objects didn't lived long enough. We had to refactor some parts of the code
- *No memory crash at runtime*
  In contrary to all C and C++ projects we did in the past, we had absolutely no memory issues that caused a crash. No segfault, no corrupted data structures, no and buffer overflow!

=== Our experience with Rust
- *The standard library* #linebreak()
  The numerous types such as `Result`, `Option`, `HashMap`, `Vec` are very useful. If we worked in C, we would miss all this plug and play experience. It also offered us advanced feature that were really helpful like `Arc` or `RwLock`. They were easy to use and well-documented.
- *Tree-Sitter library* #linebreak()
  The Tree-Sitter library was the complete opposite of the standard library of Rust, there was hardly any documentation, often demanding to read the code to understand how it works. Some incoherent behaviors were also detected on 2 ways to do the same thing.
- *Unit and integration testing* #linebreak()
  We were able to write a lot of Unit tests, and even though are program was highly concurrent we did not suffer any side effect linked to concurrency. Our tests were deterministic.
- *Be forced to manage errors*
  Not having exceptions and having the `Result` enum type, that represents a succesful result or an error is a major advantage of the language! The fact that Rust forces to check if it was succesful before trying to use the result value, adds a cost during the coding process, but this cost is largely counter balanced with the lack of runtime issues. There is always a way to "go quickly and don't care about errors" if we are okay to see the program panic (crash). We can just call `unwrap()` on `Result`, which is very helpful for unit tests or during prototyping.
- *Compilers contextual errors* #linebreak()
  The Rust compiler is the only one we know that can point so precisely to multiple locations in our code, to indicate not just where the issue is created but the important parts around this issue that are deeply related. When the borrow-checker generate errors, like "could not borrow after move", it give the location of the move and the borrow and propose a fix like "considering borrowing instead of move by adding a &".
- *Proposed fixes and refactoring* #linebreak()
  The experience in IDE with `rust-analyzer` (the Rust language server) is amazing, there is so many fixes or refactoring proposed, it helps a lot. The compiler itself also generate propositions in its console output.



loader local ref error mess


structure arc mutex dindex

pourquoi ca dans la recherche
            let chunk = chunk.to_vec(); // copy chunk

surtout lié au join skippé


exemple du verygood.rs
```rust

TSH_CACHE: Lazy\<RwLock<HashMap>>

/// A theme defining colors and modifiers to be used for syntax highlighting.
pub struct Theme<'a> {
  //...
    pub(crate) supported_highlight_names: &'a [&'a str],
}


/// HTML syntax highlighting renderer.
pub struct Renderer<'a> {
    theme: &'a theme::Theme<'a>,
}todo install instructions

```

== Future of DME ?
- Making syntax highlighting parallel
- Making grammars installation parallel
- Making a full text search

== Opportunities to dive deeper in the paradigm

TODO
- il manquait une conclusion/synthèse un peu et peut-être des idées de comment cette recherche pouvait être continuée dans un autre travail.



