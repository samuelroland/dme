use std::{fs::read_to_string, path::PathBuf};
pub mod export;
pub mod preview;
pub mod search;
pub mod theming;
pub mod util;

use preview::{
    comrak::{highlight_code_from_cached_highlighter, ComrakParser},
    preview::{Html, Previewable},
    tree_sitter_grammars::TreeSitterGrammarsManager,
    tree_sitter_highlight::TreeSitterHighlighter,
};
use theming::{
    helix::ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX,
    renderer::Renderer,
    theme::{Theme, DEFAULT_THEME},
};

/// Given a Markdown content, convert it to a full Html document that can be used as a .html file directly,
/// with all code blocks highlighted by Tree-Sitter and a default code theme applied
pub fn markdown_content_to_highlighted_html(content: &str) -> Result<Html, String> {
    let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX)
        .map_err(|e| e.to_string())?;

    let parser = ComrakParser::new()?;
    let mut html = parser.to_html(content);
    html.push_style_from_theme(&theme);
    Ok(html)
}

/// Same as `markdown_content_to_highlighted_html` with a given path to a Markdown file
pub fn markdown_file_to_highlighted_html(path: &str) -> Result<Html, String> {
    let content = read_to_string(path)
        .map_err(|e| "Couldn't find given file: ".to_string() + &e.to_string())?;
    markdown_content_to_highlighted_html(&content)
}

/// Try to detect the language via the file extension, this might returns some invalid languages
/// but should be still be useful for most use case
pub fn detect_lang_from_file_extension(path: &str) -> String {
    let path = PathBuf::from(path);
    let ext = path.extension().unwrap_or_default();
    let lang = ext.to_str().unwrap_or("");
    TreeSitterHighlighter::normalize_lang(lang).to_string()
}

/// Highlight code a piece of code in a given language, considering the TreeSitter grammar has been installed.
/// This doesn't include any Markdown interpretation (the ComrakParser is not called) to avoid injections of Markdown or HTML
/// This returns a suite of tokens as `<span>`, without any `<code>` or `<pre>`, you have to add that
/// yourself, especially if you use the CSS generated by a `Theme`, they expect a `<code>` tag around to be applied
/// Example of result of highlighting the string `color:` in CSS:
/// `<span class='property'>color</span><span class='punctuation delimiter'>:</span>`
pub fn highlight_code(lang: &str, code: &str) -> Result<Html, String> {
    let manager = TreeSitterGrammarsManager::new()?;
    let final_html = highlight_code_from_cached_highlighter(&manager, Some(lang), code);
    Ok(final_html)
}

/// Returns the CSS without any <style> tags of the `DEFAULT_THEME`
pub fn get_default_theme_css() -> String {
    let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX);
    match theme {
        Ok(theme) => {
            let renderer = Renderer::new(&theme);
            renderer.css()
        }
        Err(_) => String::default(),
    }
}

#[cfg(test)]
mod tests {
    use pretty_assertions::assert_eq;

    use crate::{
        markdown_content_to_highlighted_html,
        theming::{
            helix::ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX,
            renderer::Renderer,
            theme::{Theme, DEFAULT_THEME},
        },
    };

    // TODO: include CSS theme installation like in tree_sitter_highlight test...
    #[test]
    fn test_can_render_a_full_document_with_everything() {
        let file = r#"
---
order = 5
---

# Very nice guide
## Nice h2 title

```css
#form { color: gray; }
```
![a](test.svg)

$2+42$
"#;

        let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX)
            .map_err(|e| e.to_string())
            .unwrap();

        let renderer = Renderer::new(&theme);
        let theme_css = renderer.css();
        let html = markdown_content_to_highlighted_html(file)
            .unwrap()
            .to_safe_html_string();

        let expected = r##"<h1>Very nice guide</h1>
<h2>Nice h2 title</h2>
<pre><code class="language-css"><span class="punctuation delimiter">#</span><span class="property">form</span> <span class="punctuation bracket">{</span> <span class="property">color</span><span class="punctuation delimiter">:</span> gray<span class="punctuation delimiter">;</span> <span class="punctuation bracket">}</span></code></pre>
<p><img src="test.svg" alt="a"></p>
<p><span class="math-inline"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="prefix0a" width="39.929" height="10.017" class="typst-frame" style="width:.99823em;height:.250433em;overflow:visible" viewBox="0 0 29.947 7.513"><g class="typst-group"><use xlink:href="#prefix0b" class="typst-text" transform="matrix(1 0 0 -1 0 7.513)"></use><use xlink:href="#prefix0c" class="typst-text" transform="matrix(1 0 0 -1 7.944 7.513)"></use><use xlink:href="#prefix0d" class="typst-text" transform="matrix(1 0 0 -1 18.947 7.513)"></use><use xlink:href="#prefix0b" class="typst-text" transform="matrix(1 0 0 -1 24.447 7.513)"></use></g><defs><symbol id="prefix0b" overflow="visible"><path d="M2.607 7.326a1.99 1.99 0 0 1-1.441-.594C.759 6.336.55 5.874.55 5.313c0-.374.275-.649.616-.649a.62.62 0 0 1 .605.616.595.595 0 0 1-.616.616c-.033 0-.055 0-.077-.011.209.539.693 1.012 1.386 1.012.902 0 1.408-.781 1.408-1.727 0-.737-.374-1.529-1.122-2.365L.682.473C.539.308.55.319.55 0h4.081l.319 1.98h-.363c-.088-.561-.165-.88-.231-.979-.055-.055-.385-.077-.99-.077H1.529l1.067 1.045c.748.704 1.694 1.463 2.013 2.046q.33.577.33 1.155c0 1.298-1.012 2.156-2.332 2.156"></path></symbol><symbol id="prefix0c" overflow="visible"><path d="M7.678 3.014H4.543v3.135q0 .264-.264.264t-.264-.264V3.014H.88q-.264 0-.264-.264t.264-.264h3.135V-.649q0-.264.264-.264t.264.264v3.135h3.135q.264 0 .264.264a.27.27 0 0 1-.264.264"></path></symbol><symbol id="prefix0d" overflow="visible"><path d="M3.883 7.447c-.099 0-.187-.055-.253-.154L.308 2.189v-.396h2.871V.891c0-.198-.044-.33-.121-.385S2.772.429 2.409.429h-.275V0c.319.022.825.033 1.507.033S4.829.022 5.148 0v.429h-.275c-.363 0-.572.022-.649.077s-.121.187-.121.385v.902h1.078v.429H4.103V7.26c0 .11-.077.187-.22.187m-.638-1.364V2.222H.737Z"></path></symbol></defs></svg></span></p>"##;
        let expected_with_theme = format!("<style>{theme_css}</style>{expected}\n");
        assert_eq!(html, expected_with_theme);
    }
}
