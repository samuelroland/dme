use std::{fs::read_to_string, path::PathBuf};
pub mod export;
pub mod preview;
pub mod search;
pub mod theming;
pub mod util;

use comrak::html::escape;
use preview::{
    comrak::ComrakParser,
    preview::{Html, Previewable},
    tree_sitter_grammars::TreeSitterGrammarsManager,
    tree_sitter_highlight::TreeSitterHighlighter,
};
use theming::{
    helix::ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX,
    renderer::Renderer,
    theme::{Theme, DEFAULT_THEME},
};
use tree_sitter_loader::Loader;

/// Given a Markdown content, convert it to a full Html document that can be used as a .html file directly,
/// with all code blocks highlighted by Tree-Sitter and a default code theme applied
pub fn markdown_content_to_highlighted_html(content: &str) -> Result<Html, String> {
    let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX)
        .map_err(|e| e.to_string())?;
    let renderer = Renderer::new(&theme);
    let css = renderer.css();
    let parser = ComrakParser::new()?;
    let html = parser.to_html(content);
    let html = format!("<style>{}</style>\n\n{}", css, html.as_string());
    Ok(Html(html))
}

/// Same as `markdown_content_to_highlighted_html` with a given path to a Markdown file
pub fn markdown_file_to_highlighted_html(path: &str) -> Result<Html, String> {
    let content = read_to_string(path)
        .map_err(|e| "Couldn't find given file: ".to_string() + &e.to_string())?;
    markdown_content_to_highlighted_html(&content)
}

// Try to detect the language via the file extension, this might returns some invalid languages
// but should be still be useful for most use case
pub fn detect_lang_from_file_extension(path: &str) -> String {
    let path = PathBuf::from(path);
    let ext = path.extension().unwrap_or_default();
    let lang = ext.to_str().unwrap_or("");
    TreeSitterHighlighter::normalize_lang(lang).to_string()
}

/// Highlight code a piece of code in a given language, without any Markdown interpretation, because the ComrakParser is not called
/// This returns a suite of tokens as <span>, without any <code> or <pre>, you have to add that
/// yourself, especially if you use the CSS generated by a `Theme`, they expect a `<code>` tag around to be applied
/// Example for "color:" in CSS: `<span class='property'>color</span><span class='punctuation delimiter'>:</span>`
pub fn highlight_code(lang: &str, code: &str) -> Result<Html, String> {
    // TODO: refactor this when the perf branch is merged, to have a single code that does this
    // highlighting, this is a partially a duplicate of "impl SyntaxHighlighterAdapter for ComrakParser"
    let mut loader = Loader::new().map_err(|_| "Couldn't create loader for highlighter")?;
    let manager = TreeSitterGrammarsManager::new()?;
    let highlighter = TreeSitterHighlighter::new(&mut loader, lang, &manager);

    let final_html = match highlighter {
        Ok(highlighter) => highlighter.highlight(code).0,
        Err(_) => {
            let mut escaped = Vec::new();
            match escape(&mut escaped, code.as_bytes()) {
                Ok(_) => String::from_utf8(escaped).map_err(|e| e.to_string())?,
                Err(_) => "failed to escape code sorry...".to_string(),
            }
        }
    };

    Ok(Html(final_html))
}
