use std::{fs::read_to_string, path::PathBuf};
pub mod export;
pub mod preview;
pub mod search;
pub mod theming;
pub mod util;

use comrak::html::escape;
use preview::{
    comrak::ComrakParser,
    preview::{Html, Previewable},
    tree_sitter_grammars::TreeSitterGrammarsManager,
    tree_sitter_highlight::TreeSitterHighlighter,
};
use theming::{
    helix::ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX,
    renderer::Renderer,
    theme::{Theme, DEFAULT_THEME},
};

/// Given a Markdown content, convert it to a full Html document that can be used as a .html file directly,
/// with all code blocks highlighted by Tree-Sitter and a default code theme applied
pub fn markdown_content_to_highlighted_html(content: &str) -> Result<Html, String> {
    let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX)
        .map_err(|e| e.to_string())?;

    let parser = ComrakParser::new()?;
    let mut html = parser.to_html(content);
    html.push_style_from_theme(&theme);
    Ok(html)
}

/// Same as `markdown_content_to_highlighted_html` with a given path to a Markdown file
pub fn markdown_file_to_highlighted_html(path: &str) -> Result<Html, String> {
    let content = read_to_string(path)
        .map_err(|e| "Couldn't find given file: ".to_string() + &e.to_string())?;
    markdown_content_to_highlighted_html(&content)
}

/// Try to detect the language via the file extension, this might returns some invalid languages
/// but should be still be useful for most use case
pub fn detect_lang_from_file_extension(path: &str) -> String {
    let path = PathBuf::from(path);
    let ext = path.extension().unwrap_or_default();
    let lang = ext.to_str().unwrap_or("");
    TreeSitterHighlighter::normalize_lang(lang).to_string()
}

/// Highlight code a piece of code in a given language, without any Markdown interpretation, because the ComrakParser is not called
/// This returns a suite of tokens as `<span>`, without any `<code>` or `<pre>`, you have to add that
/// yourself, especially if you use the CSS generated by a `Theme`, they expect a `<code>` tag around to be applied
/// Example for "color:" in CSS: `<span class='property'>color</span><span class='punctuation delimiter'>:</span>`
pub fn highlight_code(lang: &str, code: &str) -> Result<Html, String> {
    // TODO: refactor this when the perf branch is merged, to have a single code that does this
    // highlighting, this is a partially a duplicate of "impl SyntaxHighlighterAdapter for ComrakParser"
    let manager = TreeSitterGrammarsManager::new()?;
    let highlighter = TreeSitterHighlighter::new(lang, &manager);

    let final_html = match highlighter {
        Ok(highlighter) => highlighter.highlight(code),
        Err(_) => {
            let mut escaped = Vec::new();
            let code = match escape(&mut escaped, code.as_bytes()) {
                Ok(_) => String::from_utf8(escaped).map_err(|e| e.to_string())?,
                Err(_) => "failed to escape code sorry...".to_string(),
            };
            Html::from(code)
        }
    };

    Ok(final_html)
}

/// Returns the CSS without any <style> tags of the `DEFAULT_THEME`
pub fn get_default_theme_css() -> String {
    let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX);
    match theme {
        Ok(theme) => {
            let renderer = Renderer::new(&theme);
            renderer.css()
        }
        Err(_) => String::default(),
    }
}
