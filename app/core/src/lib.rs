use std::{fs::read_to_string, path::PathBuf};
pub mod export;
pub mod preview;
pub mod search;
pub mod theming;
pub mod util;

use preview::{
    comrak::{highlight_code_from_cached_highlighter, ComrakParser},
    preview::{Html, Previewable},
    tree_sitter_grammars::TreeSitterGrammarsManager,
    tree_sitter_highlight::TreeSitterHighlighter,
};
use theming::{
    helix::ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX,
    renderer::Renderer,
    theme::{Theme, DEFAULT_THEME},
};

/// Given a Markdown content, convert it to a full Html document that can be used as a .html file directly,
/// with all code blocks highlighted by Tree-Sitter and a default code theme applied
pub fn markdown_content_to_highlighted_html(content: &str) -> Result<Html, String> {
    let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX)
        .map_err(|e| e.to_string())?;

    let parser = ComrakParser::new()?;
    let mut html = parser.to_html(content);
    html.push_style_from_theme(&theme);
    Ok(html)
}

/// Same as `markdown_content_to_highlighted_html` with a given path to a Markdown file
pub fn markdown_file_to_highlighted_html(path: &str) -> Result<Html, String> {
    let content = read_to_string(path)
        .map_err(|e| "Couldn't find given file: ".to_string() + &e.to_string())?;
    markdown_content_to_highlighted_html(&content)
}

/// Try to detect the language via the file extension, this might returns some invalid languages
/// but should be still be useful for most use case
pub fn detect_lang_from_file_extension(path: &str) -> String {
    let path = PathBuf::from(path);
    let ext = path.extension().unwrap_or_default();
    let lang = ext.to_str().unwrap_or("");
    TreeSitterHighlighter::normalize_lang(lang).to_string()
}

/// Highlight code a piece of code in a given language, considering the TreeSitter grammar has been installed.
/// This doesn't include any Markdown interpretation (the ComrakParser is not called) to avoid injections of Markdown or HTML
/// This returns a suite of tokens as `<span>`, without any `<code>` or `<pre>`, you have to add that
/// yourself, especially if you use the CSS generated by a `Theme`, they expect a `<code>` tag around to be applied
/// Example of result of highlighting the string `color:` in CSS:
/// `<span class='property'>color</span><span class='punctuation delimiter'>:</span>`
pub fn highlight_code(lang: &str, code: &str) -> Result<Html, String> {
    let manager = TreeSitterGrammarsManager::new()?;
    let final_html = highlight_code_from_cached_highlighter(&manager, Some(lang), code);
    Ok(final_html)
}

/// Returns the CSS without any <style> tags of the `DEFAULT_THEME`
pub fn get_default_theme_css() -> String {
    let theme = Theme::from_helix(DEFAULT_THEME, ALL_HIGHLIGHT_NAMES_SUPPORTED_BY_HELIX);
    match theme {
        Ok(theme) => {
            let renderer = Renderer::new(&theme);
            renderer.css()
        }
        Err(_) => String::default(),
    }
}
