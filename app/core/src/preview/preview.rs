use std::{borrow::Cow, path::PathBuf};

use ammonia::{Builder, UrlRelativeEvaluate};
use maplit::hashset;

use crate::theming::{renderer::Renderer, theme::Theme};

#[derive(Eq, Debug, PartialEq)]
pub struct Html {
    content: String,
    css_from_theme: String,
    image_rewrite: ImageUrlRewriteMode,
}

impl From<String> for Html {
    fn from(value: String) -> Self {
        Html {
            content: value,
            css_from_theme: String::default(),
            image_rewrite: ImageUrlRewriteMode::None,
        }
    }
}

#[derive(Eq, Debug, PartialEq)]
pub enum ImageUrlRewriteMode {
    /// The default, the URL is not touched
    None,
    // A simple prefix to put before the URL without any other change
    SimplePrefixed(String),
    /// The absolute path built for Tauri, with the asset protocol as prefix.
    /// This is intented to be used by Tauri applications
    TauriFullPath(String),
}

impl Html {
    /// Get a safe HTML version by running ammonia default cleaner with the exception of allow the
    /// class attribute on <code> and <span>, and without cleaning the CSS from the Theme
    pub fn to_safe_html_string(&self) -> String {
        // NOTE: update SECURITY.md if the rules need to change
        let mut cleaner = Builder::default();
        cleaner.add_tag_attributes("code", &["class"]); // authorize the class attribute for <code> because we need to keep highlight names CSS classes
        cleaner.add_tag_attributes("span", &["class"]); // same as for <code>
        cleaner.add_tag_attributes("img", &["src"]);
        // Allow inline SVG, to allow math expressions to be rendered
        // The list of tags has been defined by hand by looking at the minimum for math equations.
        // Some of them might be missing.
        // See https://developer.salesforce.com/docs/platform/lightning-components-security/guide/lws-sanitize-svg.html
        cleaner.add_tag_attributes("p", ["class"]); // to allow the <p class="math-block">
        cleaner.add_tags(["svg", "g", "use", "path", "defs", "symbol"]);
        cleaner.add_tag_attributes(
            "svg",
            [
                "xmlns", // this include xmlns:xlink
                "xlink", "id", "class", "style", "width", "height", "viewBox",
            ],
        );
        cleaner.add_tag_attributes("g", ["class", "transform"]);
        cleaner.add_tag_attributes(
            "use",
            [
                "xlink:href",
                "xlink",
                "href",
                "class",
                "transform",
                "x",
                "y",
                "fill",
                "fill-rule",
            ],
        ); // TODO: make sure xlink:href can be safe ?
           // <path fill="none" stroke="#000" stroke-width=".528" d="M0 1.067h6.292" class="typst-shape"></path>
        cleaner.add_tag_attributes("path", ["d", "class", "fill", "stroke", "stroke-width"]);
        cleaner.add_tag_attributes("defs", ["id"]);
        cleaner.add_tag_attributes("symbol", ["id", "overflow"]);

        cleaner.strip_comments(true);

        // Rewrite the image URLs with a prefix if provided, to adapt to the platform (web needs
        // sometimes a subfolder for images, desktop app needs an absolute path prefix, ...)
        match &self.image_rewrite {
            ImageUrlRewriteMode::None => {}
            ImageUrlRewriteMode::SimplePrefixed(prefix) => {
                struct PurePrefix {
                    prefix: String,
                }
                impl<'a> UrlRelativeEvaluate<'a> for PurePrefix {
                    fn evaluate<'url>(&self, url: &'url str) -> Option<Cow<'url, str>> {
                        // If we have an anchor, we don't want to touch it, because it doesn't need any prefix.
                        // In case of <use href="#abc" > we don't want touch this value.
                        if url.trim().starts_with("#") {
                            Some(Cow::Borrowed(url))
                        } else {
                            let mut copy = self.prefix.clone();
                            copy.push_str(url);
                            Some(Cow::Owned(copy))
                        }
                    }
                }
                cleaner.url_relative(ammonia::UrlRelative::Custom(Box::new(PurePrefix {
                    prefix: prefix.to_owned(),
                })));
            }
            ImageUrlRewriteMode::TauriFullPath(path) => {
                let new_url_schemes = hashset!["asset"];
                cleaner.add_url_schemes(new_url_schemes);

                cleaner.url_relative(ammonia::UrlRelative::Custom(Box::new(TauriPathRewriter {
                    path: path.to_owned(),
                })));
            }
        }

        cleaner.clean(&self.content).to_string()
    }

    /// Push the style generated by a given Theme, this style will not be cleaned !
    pub fn push_style_from_theme(&mut self, theme: &Theme) {
        let renderer = Renderer::new(theme);
        self.css_from_theme.push_str(&renderer.css());
    }

    pub fn set_image_rewrite(mut self, mode: ImageUrlRewriteMode) -> Self {
        self.image_rewrite = mode;
        self
    }
}

struct TauriPathRewriter {
    path: String,
}

/// This is just a reimplementation of Tauri's JavaScript function convertFileSrc()
/// to have a safe Rust only HTML generation without any JavaScript HTML manipulation
/// https://v2.tauri.app/fr/reference/javascript/api/namespacecore/#convertfilesrc
///
/// See implementation to better understand why the tauri_prefix
/// https://github.com/tauri-apps/tauri/blob/18464d9481f4d522c305f21b38be4b906ab41bd5/crates/tauri/scripts/core.js#L13
impl<'a> UrlRelativeEvaluate<'a> for TauriPathRewriter {
    fn evaluate<'url>(&self, url: &'url str) -> Option<std::borrow::Cow<'url, str>> {
        // If we have an anchor, we don't want to touch it, because it doesn't need any prefix.
        // In case of <use href="#abc" > we don't want touch this value.
        if url.trim().starts_with("#") {
            Some(Cow::Borrowed(url))
        } else {
            #[cfg(target_os = "windows")]
            let tauri_prefix = "http://asset.localhost/";
            #[cfg(target_os = "android")]
            let tauri_prefix = "http://asset.localhost/";
            #[cfg(target_os = "linux")]
            let tauri_prefix = "asset://localhost/";
            #[cfg(target_os = "macos")]
            let tauri_prefix = "asset://localhost/";

            let absolute_path = PathBuf::from(&self.path)
                .join(url)
                .into_os_string()
                .to_string_lossy()
                .to_string();
            let encoded_absolute_path = urlencoding::encode(&absolute_path);
            let result = format!("{tauri_prefix}{encoded_absolute_path}");
            Some(Cow::Owned(result))
        }
    }
}

/// A component that will be able to preview a given document into HTML
pub trait Previewable {
    fn to_html(&self, source: &str) -> Html;
}

#[cfg(test)]
mod tests {
    use std::fs::write;

    use crate::preview::{
        comrak::ComrakParser,
        preview::{Html, ImageUrlRewriteMode, Previewable},
    };
    use pretty_assertions::assert_eq;

    #[test]
    fn test_images_path_can_be_left_untouched() {
        let given = "# Sky\n![super sky](sky.png)";
        let result = ComrakParser::new()
            .unwrap()
            .to_html(given)
            .set_image_rewrite(ImageUrlRewriteMode::None)
            .to_safe_html_string();
        assert_eq!(
            result,
            format!("<h1>Sky</h1>\n<p><img src=\"sky.png\" alt=\"super sky\"></p>\n")
        );
    }

    #[test]
    fn test_images_path_can_be_prefixed_and_canonized() {
        let given =
            "# Sky\n![super sky](sky.png)\n![this is not prefixed !](#introduction-to-the-subject)";

        let result = ComrakParser::new()
            .unwrap()
            .to_html(given)
            .set_image_rewrite(ImageUrlRewriteMode::SimplePrefixed(
                "/static/images/".to_string(),
            ))
            .to_safe_html_string();
        let newpath = "/static/images/sky.png";
        assert_eq!(
            result,
            format!("<h1>Sky</h1>\n<p><img src=\"{newpath}\" alt=\"super sky\">\n<img src=\"#introduction-to-the-subject\" alt=\"this is not prefixed !\"></p>\n")
        );
    }

    #[test]
    fn test_images_path_can_be_prefixed_with_absolute_path_for_tauri() {
        let given = "# Sky
![super sky](sky.png)
![super sky on external website](https://great-website.com/sky.png)
![super sky](../../bench/sky.png)
![this is not prefixed !](#introduction-to-the-subject)
![nice path](../images-de-fous/super_Schema$BIEN3joli.png)";

        // TODO: should we support path with spaces ??
        let result = ComrakParser::new()
            .unwrap()
            .to_html(given)
            .set_image_rewrite(ImageUrlRewriteMode::TauriFullPath(
                "/home/sam/report/".to_string(),
            ))
            .to_safe_html_string();

        #[cfg(target_os = "windows")]
        let tauri_prefix = "http://asset.localhost/";
        #[cfg(target_os = "android")]
        let tauri_prefix = "http://asset.localhost/";
        #[cfg(target_os = "linux")]
        let tauri_prefix = "asset://localhost/";
        #[cfg(target_os = "macos")]
        let tauri_prefix = "asset://localhost/";

        assert_eq!(
            result,
            format!(
                "<h1>Sky</h1>
<p><img src=\"{tauri_prefix}%2Fhome%2Fsam%2Freport%2Fsky.png\" alt=\"super sky\">
<img src=\"https://great-website.com/sky.png\" alt=\"super sky on external website\">
<img src=\"{tauri_prefix}%2Fhome%2Fsam%2Freport%2F..%2F..%2Fbench%2Fsky.png\" alt=\"super sky\">
<img src=\"#introduction-to-the-subject\" alt=\"this is not prefixed !\">
<img src=\"{tauri_prefix}%2Fhome%2Fsam%2Freport%2F..%2Fimages-de-fous%2Fsuper_Schema%24BIEN3joli.png\" alt=\"nice path\"></p>
"
            )
        );
    }
    #[test]
    fn test_math_svg_is_not_sanitized_nor_link_rewritten() {
        // Note: this is simplified SVG to make it shorter here, it doesn't show anything because I broke it...
        let svg = r##"
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="a" width="53.893" height="10.017" class="typst-frame" style="width:1.34734em;height:.250433em;overflow:visible" viewBox="0 0 40.42 7.513">
<g class="typst-group">
<use xlink:href="#b" fill="#000" class="typst-text" transform="matrix(1 0 0 -1 0 7.513)"></use>
<use xlink:href="#c" fill="#000" class="typst-text" transform="matrix(1 0 0 -1 11.658 7.513)"></use>
</g>
<defs>
<symbol id="b" overflow="visible">
<path d="M6.105 7.513h-3.52c-. 2.904c.088.374.088.374.55.374Z"></path>
</symbol>
<symbol id="c" overflow="visible">
<path d="M7.678 4.037H.88c-.176 0 1-.264.253"></path>
</symbol>
</defs>
</svg>
"##;

        let html = Html::from(svg.to_string())
            .set_image_rewrite(ImageUrlRewriteMode::SimplePrefixed(
                "https://lxup.org/public/".to_string(),
            ))
            .to_safe_html_string();
        std::fs::write("/tmp/cleaned.svg", &html.trim());
        assert_eq!(svg, html);
    }
}
